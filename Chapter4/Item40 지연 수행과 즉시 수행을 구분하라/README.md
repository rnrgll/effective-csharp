# 40\. 지연 수행과 즉시 수행을 구분하라

데이터를 넘기는 코드(즉시 수행)와 코드를 넘기는 코드(지연 수행)는 실행 시점, 호출 횟수, 부수효과 관점에서 완전히 다른 의미를 가진다.

## 40.1 즉시 수행 vs 지연 수행

### 40.1.1 명령형 / 즉시 수행 (Imperative / Eager)

```csharp
var answer = DoStuff(Method1(), Method2(), Method3());
```

#### 실행 순서

1.  `Method1()` 실행
2.  `Method2()` 실행
3.  `Method3()` 실행
4.  반환된 값들이 DoStuff에 전달됨

#### 특징

*   항상 즉시 실행됨
*   호출 순서 고정
*   부수효과가 정확히 1번 발생
*   수행비용이 작을 때 유리

#### 적합한 경우

*   계산 비용이 낮을 때
*   순서가 중요할 때
*   부수효과가 의도적으로 필요한 로직일 때 (ex: 로깅, 인증 검증)

### 40.1.2 선언적 / 지연 수행 (Declarative / Lazy)

```csharp
var answer = DoStuff(
    () => Method1(),
    () => Method2(),
    () => Method3()
);
```

#### 실제 동작

*   Method1/2/3을 **실행하지 않고**,
    
    ‘Method1을 실행하는 방법(람다)’을 DoStuff에 넘김
    
*   DoStuff 내부에서:
    
    *   필요할 때만 실행된다
    *   호출 순서가 달라질 수 있다
    *   여러 번 실행되거나
    *   아예 실행되지 않을 수도 있다

#### 특징

*   실행 시점이 호출자에게서 사라짐
*   실행 제어권이 DoStuff로 이동
*   부수효과가 달라질 수 있음
*   메모리를 아끼고 싶을 때 유리

#### 적합한 경우

*   계산 비용이 큰 작업을 “필요할 때만” 하길 원할 때
*   조건에 따라 실행 여부가 달라지는 로직
*   대용량 처리, 스트리밍 처리

### 40.1.2 부수 효과에 의한 차이

#### 순수 함수

순수함수의 조건

*   같은 입력 → 같은 출력
*   외부 상태 변경 없음
*   I/O 없음
*   시간/랜덤값 의존 없음

⇒ 언제 실행하든, 몇 번 실행하든 결과가 같다

→ 즉시 수행과 지연 수행을 섞어도 괜찮다. 결과가 거의 동일하다.

#### 부수 효과가 있는 경우

부수 효과가 있는 경우 즉시 수행과 지연 수행간의 실행 결과가 달라진다.
| 구분 | 즉시 수행 | 지연 수행 |
| --- | --- | --- |
| 호출 횟수 | 1번 | 0~N번 |
| 호출 시점 | 고정 | 불확정 |
| 호출 순서 | 고정 | 불확정 |
| 의미 | 예측 가능 | 예측 어려움 |

> #### 부수 효과 예시
> <ul><li>DateTime.Now</li><li>Random.Next()</li><li>Console.WriteLine()</li><li>DB 조회</li><li>네트워크 요청</li><li>전역 변수 변경</li><li>컬렉션 수정</li></ul>

## 40.2 데이터 vs 함수 — 무엇을 넘겨야 하는가?
| 구분 | 데이터 전달 | 함수 전달 |
| --- | --- | --- |
| 언제 계산됨? (평가 시점) | 즉시 계산됨 | 나중에 필요할 때 계산됨 |
| 실행 제어권 | 호출자 | 호출된 함수 내부 |
| 부수효과 | 즉시 발생 | 발생 시점 불명 |
| 메모리 사용 | 데이터 저장 비용 필요 | 필요 없음 |
| 대용량 처리 | 느림 | 효율적 |

#### 데이터를 전달하는 방식이 적합한 경우

*   입력 데이터가 작다
*   즉시 값이 필요하다
*   부수효과가 있다

#### 함수를 전달하는 방식이 적합한 경우

*   입력/출력 데이터가 매우 크다
*   모든 결과를 저장하기 어렵다
*   원격 실행(DB, 네트워크)을 활용할 수 있다
*   지연 수행이 성능에 유리하다

### 캐싱 + 람다

```csharp
var cost = ExpensiveOperation(); // 딱 1번 계산

var result = DoStuff(
    () => cost,
    () => CheapOperation(),
    () => AnotherOperation()
);
```

*   비싼 연산은 즉시 계산 후 캐싱
*   나머지는 지연 수행

## 40.3 LINQ to SQL에서의 실행 모델

*   LINQ to SQL에서 작성한 쿼리는 **로컬(C#)** 에서 실행되지 않고, **원격 데이터 저장소(DB 엔진)** 에서 실행될 수 있다.
*   LINQ to SQL은 값을 넘기는 것이 아니라 코드(표현식)을 넘긴다.

즉, 다음 코드는:

```csharp
var q = db.Employees.Where(e => e.Age >30);
```

*   아직 SQL을 실행한 것이 아니다. 아직 DB 요청도 없다.
*   그저 **표현식 트리를 구성한 것뿐**이다.

### 실행 시점 — `ToList()` 같은 연산을 만날 때

```csharp
var list = q.ToList(); // 여기서 비로소 SQL 실행
```

실행 시 LINQ to SQL은:

*   표현식 트리를 분석
*   DB에서 실행 가능한 부분을 추출
*   로컬에서 먼저 평가해야 하는 부분을 실행
*   SQL 생성
*   SQL 서버에서 실제 쿼리 실행
*   결과를 C#으로 가져옴
