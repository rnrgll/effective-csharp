# 16\. 생성자 내에서는 절대로 가상 함수를 호출하지 말라

객체가 완전히 생성되기 전에 가상 함수를 호출하면 이상 동작을 일으킨다.

생성자가 수행을 완료하기 전까지는 객체가 완전히 생성되었다고 할 수 없기 때문에, **생성자 내에서 가상함수를 호출하면 언어에 따라 오류가 발생하거나 예측 불가능한 동작이 발생할 수 있다.**

## 16.1 아직 완성되지 않은 객체

생성자가 실행 중이라는 것은

*   객체의 메모리는 할당되었지만
*   파생 클래스의 초기화는 아직 끝나지 않았을 수 있다.

즉, 타입은 결정되었지만, 상태는 미완성인 객체라고 볼 수 있다.

이 상태에서 가상 함수를 호출하면 **언어의 가상 디스패치 규칙에 따라 예기치 않은 메서드가 호출될 수 있으며**, 그 결과는 C#과 C++에서 서로 다르게 나타난다.

### 16.1.1 예제

```csharp
class B
{
	protected B()
	{
		VFunc();
	}
	protected virtual void VFunc()
	{
		Console.WriteLine("VFunc in B");
	}
}

class Derived : B
{
	private readonly string msg = "Set by initializer";
	
	public Derived(string msg)
	{
		this.msg = msg;
	}
	protected override void VFunc()
	{
		Console.WriteLine(msg);
	}
	public static void Main()
	{
		var d = new Derived("Construced in main");
	}
}

```

*   `B`의 생성자에서 가상 함수 `VFunc()`를 호출한다
*   `Derived`생성자는 자신의 필드 `msg`를 사용하며, msg를 초기화한다.
*   또한, `Derived` 는 가상 함수 `VFunc()` 을 오버라이드 하고 있다.

### 16.1.2 VTable (가상 함수 테이블)

*   가상 함수 테이블은 객체지향 프로그래밍에서 **동적 디스패치**를 구현하기 위한 메커니즘
*   가상 함수를 포함하는 클래스가 있으면 컴파일러가 가상 함수의 주소를 저장하는 테이블을 생성한다.
*   각 객체에 VTable을 가리키는 vptr(virtual pointer)를 추가한다.
*   가상 함수 호출 시 vptr을 통해 VTable에 접근하고 테이블에서 올바른 함수 주소를 찾아 실행한다.

### 16.1.3 C# 에서의 동작 방식

**C#에서는 생성자 실행 중에도 객체의 타입 정체성은 이미 파생 타입으로 확정된다.**

#### Method Table

*   CLR이 타입 로드 시점(객체 생성 전)에 **해당 타입의 Method Table**을 만든다.
    
    *   부모의 클래스 메서드
    *   파생 클래스가 오버라이드한 메서드
    *   가상 메서드 슬롯 정보
    
    가 완성된다.
    
*   객체 생성 시 GC가 힙에 메모리를 할당하고 **객체 헤더에 Method Table을 가리키는 포인터(Method Table Pointer)를 저장한다.**
    
*   생성자 실행 중에도 이 Method Table Pointer는 변하지 않는다.
    

#### 가상 함수 호출 흐름

*   `new Derived()`가 호출되는 순간 CLR은 **Derived 타입의 객체**를 생성한다.
*   객체는 생성자 실행 이전부터 **Derived 타입 Method Table을 가리킨다.**
*   부모의 생성자에서 가상 함수를 호출하면, **Method Table을 기준으로 Derived 에서 오버라이드된 메서드를 호출한다. ⇒ 다형성 적용**

#### 문제점

*   파생 클래스의 생성자는 아직 실행되지 않은 상태다.
*   파생 클래스에서만 초기화되는 필드는 아직 기본값 상태일 수 있어 **null reference 오류 혹은 예상치 못한 결과가 나올 수 있다.**
*   위 예제에서는
    *   `msg` 필드는 필드 초기화 구문에 의해 `"Set by initializer"`로 설정되어 있고
    *   Derived 생성자는 실행되지 않았으므로, 매개변수 값 `"Constructed in Main"`은 아직 대입되지 않았다

### 16.1.4 C++ 에서의 동작 방식

C++에서는 생성자 실행 중 객체의 타입이 **단계적으로 확정**된다.

즉, 생성자 실행 흐름에 따라 객체가 어느 타입으로 취급되는지가 달라진다.

#### 타입 확정 흐름

*   Base 생성자 실행 중
    *   객체는 **Base 타입**
    *   **VTable은 Base를 가리킴**
*   Derived 생성자 진입 시점에
    *   객체는 **Derived 타입**
    *   **VTable이 Derived로 교체됨**
*   Base 생성자에서 가상 함수 호출하면 **Base 클래스의 구현이 호출된다. ⇒ 다형성이 적용되지 않는다.**

#### 문제점 - 순수 가상 함수

```cpp
class Base {
    Base() { Foo(); }
    virtual void Foo() = 0;
};
```

*   부모 생성자에서 호출한 가상함수는 부모의 메서드를 호출하게 된다.
*   `Base`에 `virtual void Foo() = 0;` (구현 없음) ⇒ 연결할 구현체가 없으므로 **런타임 크래시가 발생한다.**

### C# vs C++ 정리
| 구분 | C# | C++ |
| --- | --- | --- |
| 생성자 중 타입 정체성 | 항상 파생 타입 | 생성자 단계에 따라 변경 |
| 가상 함수 디스패치 | 파생 클래스 메서드 호출(다형성 O) | 현재 생성 중인 타입 기준(다형성 X) |
| 순수 가상 함수 호출 | 호출 대상은 존재 | 크래시 발생 |
| 주요 문제 | 미초기화 상태 사용 | 런타임 크래시 |


## 16.2 가상 함수 오버라이딩 문제

생성자에서 가상 함수를 호출하면 베이스 클래스는 **파생 클래스의 구현에 의존**하게 된다.

*   파생 클래스 구현이 바뀌면 베이스 클래스 생성자의 동작도 바뀐다.
*   초기화 순서에 따라 오류가 나기도 하고, 예상치 못한 결과, 잘못된 결과가 나온다.

따라서, 되도록 생성자에서 가상 함수를 호출하지 말자!

## 16.3 Tools

Visual Studio에 포함된 FxCop나 정적 코드 분석기가 관련 규칙을 통해 이러한 코드 패턴을 쉽게 파악할 수 있다.
