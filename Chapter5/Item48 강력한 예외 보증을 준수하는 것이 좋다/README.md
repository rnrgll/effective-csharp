# 48\. **강력한 예외 보증을 준수하는 것이 좋다**

예외를 발생시키면 응용프로그램의 제어 흐름이 바뀌고 예상한 작업이 제대로 수행되지 않을 수 있다.

그 순간까지 진행된 작업들이 어떤 상태를 남기느냐가 문제가 되는데, ‘이 함수는 예외가 나더라도 최소한 여기까진 보장한다’라는 계약(보증)을 해야 한다.

보증에는 세 단계가 있다.

1.  기본 보증
2.  강력한 보증
3.  예외 없음 보증

## 48.1 기본 보증

기본 보증은 예외가 발생하더라도 **자원(메모리 등)은 누수되지 않고, 객체 상태가 ‘유효한’ 상태로 남는다.**

*   유효한 상태(valid)라는 것은 값이 바뀔 수는 있지만, 타입의 불변식은 유지된다는 것 → 망가진 상태가 아님!
    
*   .NET CLR은 기본 보증을 준수한다.
    
    *   관리하는 힙 메모리는 GC로 인해 누수되지 않는다.
    *   하지만, 파일 핸들, 소켓 등 IDisposable 리소스는 개발자가 직접 처리해야 한다. → using, try/finally 같은 패턴을 써야 함
*   하지만, 객체 상태가 어떻게 바뀌었는지 모른다.
    
    예를 들어, 컬렉션에 임의이 요소를 추가하는 `Add()` 메서드가 있을 때,
    
    *   내부적으로 배열을 리사이즈하거나 요소를 이동시키는 과정에서 예외가 발생하면
    *   리스트에는 일부 요소가 추가되었을 수도 있고, 내부 배열의 크기가 변경되었을 수도 있고, Count 값은 업데이트가 되기 전이거나 후일 수도 있다.
    *   즉, **Add 요청 전과 동일한 상태라는 보장이 없다.** → catch에서 이를 고려해야 한다.

## 48.2 강력한 보증

기본 보증 + **예외 발생 시에도 프로그램의 상태가 변경되지 않았음**을 추가로 보증한다

→ 성공하면 완전히 적용, 실패하면 아무 일도 안 일어난 것처럼 기존 상태가 유지된다.

→ DB 트랜잭션의 원자성과 비슷한 개념

### 48.2.1 강력한 보증의 장점

*   강력한 보증을 준수하면 예외를 catch한 경우에도 응용프로그램을 이어서 수행하기가 수월하다.
*   catch 블록에서 ‘이제 상태가 어떻게 되어 있을까’를 고민하지 않아도 된다. 그냥 작업이 안 된 걸로 생각하고 그대로 다음 로직을 이어서 작성할 수 있다.

### 48.2.2 강력한 보증을 위한 방법

1.  데이터는 변경 불가능하게 설계한다.
    
    *   값 타입에 저장하거나
        
    *   Immutable 객체를 사용하면 ‘원자성’이 쉽게 지켜진다.
        
        실패해도 기존 상태는 그대로고, 성공하면 새 객체만 사용하면 된다. ‘중간 상태’가 없기 때문에 원자성이 쉽게 지켜진다.
        
    
    ```csharp
    var s1 = "hello";
    var s2 = s1.Replace("h", "H"); // 예외가 발생해도 s1은 변하지 않음
    ```
    
2.  LINQ 쿼리를 이용하는 함수형 프로그래밍 스타일을 사용한다.
    
    함수형 프로그래밍이란 **상태를 변경하지 않고, 부작용이 없는 함수**들을 조합해 프로그램을 만드는 방식을 말한다.
    
    *   부작용이 없다 : 함수는 오직 결과만 반환하고 외부 상태를 변경하지 않는다.
        
        *   부작용 : 전역 변수 수정, 입력 매개변수 변경, 파일/DB 쓰기, UI 업데이트 등 **함수 밖의 세계를 바꾸는 일**
        
        ```csharp
        // 함수형 스타일
        int Add(int a, int b) => a + b;
        ```
        
    *   입력이 같으면 항상 같은 결과를 출력한다.
        
    *   값을 바꾸는게 아니라 새 값을 만들어내는 방식을 사용한다.
        
        > #### LINQ
        > <ul><li><strong>LINQ는 원본을 변경하지 않는다.</strong></li>
        > 
        > <pre><code class="language-csharp">var newList = oldList.Where(x =&gt; x.IsActive).ToList();</code></pre>
        > <ul><li>oldList를 수정하지 않음</li><li><strong>새로운 시퀀스</strong>를 만들어내고, 실패하면 <strong>예외가 나도 원본이 손상되지 않는다.</strong></li></ul></li>
        > <li><p>LINQ 쿼리를 사용하면 기본적으로 강력한 예외 보증 요건을 준수하게 된다.</p></li></ul>
        
    *   즉, 함수형 프로그래밍은 원본 데이터를 변경하지 않고 항상 새 값을 반환하며, 부작용이 없기 때문에 예외가 발생해도 상태가 망가지지 않는다.
        
3.  복사-수정-스왑 패턴을 사용한다.
    
    함수형 스타일을 사용할 수 없는데, 기존 객체를 변경해야 한다면 **복사-수정-스왑 패턴을 사용하여 강력한 보증을 구현해야 한다.**
    

### 48.2.3 복사-수정-스왑 패턴

1.  기존 데이터의 복사본을 생성한다.
2.  복사해 둔 데이터를 수정한다. (수정과정에서 예외가 발생할 수 있음)
3.  **예외가 발생하지 않는 연산(스왑, 참조, 교체 등)으로 원본과 교체한다.**

```csharp
private List<PayrollData> _data = new();

public void UpdateData()
{
    // 1. 실패 가능성이 있는 작업
    var temp = UnreliableOperation();       // 여기서 예외 날 수 있음

    // 2. 복사본 준비
    var newList = temp.ToList();           // 여기서도 예외 날 수 있음

    // 3. 예외가 나면 아직 _data는 건드려지지 않음
    //    여기까지 모두 성공했다면 이제 안전한 스왑만 남음
    _data = newList;                       // 이 대입 자체는 예외가 안 난다고 가정
}
 
```

### 48.2.4 강력한 보증을 충족시키기 어려운 경우

1.  루프
    
    *   루프에서 여러 개의 객체의 상태를 차례대로 변경하는 작업 도중 예외가 발생하면 일부 변경된 상태가 남아버린다.
    *   루프를 실행 전 상태로 백업하기 위해서는 객체들을 깊은 복사해야 하고, 계속 백업을 해주어야 하기 때문에 비효율적이고 성능도 크게 떨어진다.
    *   그래서 강력한 보증을 포기하고 기본 보증만 제공하는 경우가 많다.
2.  참조 타입을 복사-스왑하는 경우
    
    ```csharp
    private List<PayrollData> data;
    public IList<PayrollData> MyCollection;
    {
    	get
    	{
    		return data;
    	}
    
    }
    
    public void UpdateData()
    {
    		// 실패할 가능성이 있는 신뢰할 수 없는 작업을 수행
    		var temp = UnreliableOpreation();
    		
    		data = temp;
    }
    ```
    
    *   외부 코드가 기존 참조를 들고 있었을 경우, 새로운 데이터로 바뀌지 않고 `update` 후에도 여전히 기존 데이터를 가리키고 있게 된다.
    *   이 경우 참조 중인 객체 내의 데이터를 수정해야 하며, 이 과정에서 예외가 발생하지 않도록 보증하는 수 밖에 없다.

### 48.2.5 봉투-편지 패턴

#### 문제 상황

컬렉션(List<T>) 내부 데이터를 “기존 데이터 제거 → 새 데이터 추가” 방식으로 갱신할 때,

```csharp
data.Clear();
foreach (var item in temp)
    data.Add(item);
```

*   `Clear()` → `Add()` 과정은 원자적이지 않다.
*   `Clear()`는 이미 기존 데이터를 제거함
*   `Add()` 반복 중 예외가 발생하면 일부 데이터만 들어간 **중간 상태**가 된다
*   예외 발생 시 이전 상태로 돌아갈 수 없으므로 **강력한 예외 보증을 충족할 수 없다**

#### 해결책 : 봉투-편지 패턴

**실제 데이터를 보관하는 객체(List)를 직접 노출하지 않고,** 그걸 한 번 더 감싸는 **래퍼(Envelop)를 두는 구조**

```csharp
// private List<PayrollData> data;
private Envelope data; // Envelope 내부에 실제 List가 있음
public IList<PayrollData> MyCollection => data;
```

외부에서는 Envelope만 보게 되고, 실제 List는 Envelope 내부에 숨겨진다.

##### Envelop 내부 구현

```csharp
//Envelop 내부

public class Envelope : IList<PayrollData>
{
    private List<PayrollData> data = new();

    public void SafeUpdate(IEnumerable<PayrollData> sourceList)
    {
        var updates = sourceList.ToList(); // 복사본 생성
        data = updates;  // 원자적인 참조 교체
    }
}
```

*   실패 가능성이 있는 연산은 전부 복사본을 생성해서 처리하고,
    
*   처리가 모두 끝난 후 마지막에 데이터 교체(`data=updates;`)를 해서 참조 교체가 원자적으로 이루어진다.
    
*   **외부 참조 불일치 문제 해결**
    
    *   외부는 실제 리스트가 아니라 **Envelope 객체만** 참조한다.
    *   Envelop 자체는 바뀌지 않으므로 외부에서 참조를 들고 있어도 항상 최신의 데이터 상태를 볼 수있다.
    *   단, 외부에서 Envelop 내부 데이터에 대한 참조를 직접 들고 있게 된다면 외부 참조 불일치 문제를 해결할 수 없다.
*   **강력한 예외 보증 충족**
    
    *   업데이트 과정에서 예외가 발생할 수 있는 작업은 모두 **복사본에서 수행된다.**
    *   따라서 실패하더라도 원본 데이터를 건드리지 않았기 때문에 기존 상태를 유지할 수 있다. 중간상태가 외부로 노출되지 않는다.

## 48.3 예외 없음 보증

작업이 결코 실패하지 않으며 따라서 예외가 발생하지도 않음을 보증하는 것

*   특정 메서드가 예외를 전혀 발생시키지 않으며, 항상 완벽하게 수행, 예외가 밖으로 전파되지 않는다.
*   주로 일부 메서드나 루틴에만 적용한다.

### 예외 없음 보증을 사용해야 하는 경우

*   finalizer : 예외를 일으키면 리소스를 온전히 정리하지 못한 채 프로그램이 종료된다.
*   Dispose() : 기존 예외를 무시하고 새로운 예외 발생, 예외를 시스템이 삼켜버려 어디서 발생했는지 정보도 잃는다.
    *   예시
        
        ```csharp
        using (var conn = new DBConnection())
        {
            conn.Open();
            throw new InvalidOperationException("업무 오류!"); // 원래 예외
        }
        
        //Dispose() 부분
        public void Dispose()
        {
            throw new Exception("Dispose 실패!");
        }
        ```
        
        `Dispose()` 안에서 또 예외가 발생하면
        
        1.  `Open()` 중 발생한 예외(InvalidOperationException)가 발생
        2.  finally 실행 → Dispose 호출
        3.  Dispose에서 새 예외 발생
        4.  **원래 예외(InvalidOperationException)가 사라짐**
        5.  Dispose에서 발생한 예외만 밖으로 나오게 됨
*   예외의 When절 : 기존 예외는 사라지고 새로운 예외를 생성한다.
*   델리게이트의 대상 메서드 안 : 멀티캐스트 델리게이트의 경우 대상이 되는 메서드가 예외를 일으키면 다른 메서드가 호출이 되지 않는 문제 발생한다.
