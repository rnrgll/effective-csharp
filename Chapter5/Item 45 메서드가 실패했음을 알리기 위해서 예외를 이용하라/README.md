# 45\. 메서드가 실패했음을 알리기 위해서 예외를 이용하라

## 45.1 예외의 목적

요청된 작업을 제대로 수행할 수가 없다면 예외를 발생시켜 실패가 발생했음을 알려야한다.

이때 예외는 단순히 **“실패했다”는 사실**만 알리는 것이 아니라,

**실패의 근본 원인을 진단하고, 가능하다면 오류 상황을 수정하는 데 필요한 모든 정보를 함께 제공**해야 한다.

즉, 예외의 목적은

*   실패했음을 알린다.
*   왜 실패했는지에 대한 원인을 전달한다
*   복구 가능한 상황인지 판단할 수 있는 정보를 제공한다.

### 주의점 : 예외를 일반적인 실행 흐름 제어 수단으로 사용하지 말기

```csharp
try
{
    int value = int.Parse(input);
    // 정상 흐름
}
catch
{
    // 실패하면 여기로 오는 걸 기대
}

```

위와 같은 코드를 작성해서는 안된다.

*   코드의 가독성이 떨어진다.
*   예외 처리는 일반 조건문보다 비용이 크기 때문에 성능에도 불리하다.
*   코드의 의도를 파악하기 어려워진다.

예외는 ‘비정상적인 상황’을 표현하기 위한 수단이지 if/else문 처럼 조건 분기, 실행 흐름 제어를 위한 수단이 아니다.

## 45.2 오류 코드 vs 예외

### 45.2.1 오류 코드(반환 코드) 방식

*   실패를 표현하기 위한 반환 값
*   반환 타입(int, bool, enum 등)으로 성공/실패를 표현

#### 특징

*   **메서드의 원형에 영향을 미친다.**
    
    *   원래 반환해야 할 값을 반환형으로 사용할 수 없다.
    *   성공/실패를 표현하기 위한 값을 반환형으로 사용하게 된다.
    *   메서드의 본래 의미가 원형 단계에서부터 바뀌게 된다.
*   반환 코드는 메서드 호출자에 의해 처리된다.
    
    *   이로 인해 오류 코드를 검사하고 활용하는 코드가 정상적인 실행 흐름에 섞이게 된다.
    *   핵심 로직이 흐려지기 쉽다.
*   실패 여부 외에 추가적인 정보를 전달하기 어렵다.
    
*   쉽게 무시될 수 있다.
    
*   **실패 결과가 나오더라도 메서드 그 자체는 성공적으로 수행을 완료한 것으로 간주된다.**
    
     **=> 이후 프로그램 흐름을 계속 이어나갈 수 있다.**
    
    ```csharp
    File.Exists(path); // 파일이 없어도 파일의 존재 여부를 확인했다는 목적은 달성
    ```
    

### 45.2.2 예외 방식

*   반환값이 아니라 **실행 흐름 자체를 중단시켜 실패를 알린다.**

#### 특징

*   예외는 클래스 타입이며 `System.Exception` 계열로 구성된다.
    
*   메시지, 원인, 내부 예외 등 추가적인 정보를 함께 전달할 수 있다.
    
*   실패 정보가 반환값이 아니라 예외 객체로 전달되므로 **메서드의 원형을 바꾸지 않고도 실패를 알릴 수 있다.**
    
*   **콜 스택을 따라 전파된다.**
    
*   **에러 발생 지점과 처리 지점을 분리할 수 있다.**
    
    *   저수준 메서드에서는 문제가 발생했다는 사실만 알리고, 상위 호출부에서 실제 대응 방법을 결정한다.
    *   책임이 분리되고, 에러 처리 코드가 한 곳에 모이며, 로직과 처리 코드가 섞이지 않는다.
*   **예외는 작업 자체가 실패했음을 의미한다.** 예외 처리를 하거나, 처리 가능한 상태로 북구해야만 프로그램을 계속 실행할 수 있다.
    
    ```csharp
    File.Open(path); // 파일이 존재하고, 접근 권한이 있는 경우에만 성공. 실패 시 예외 처리 없으면 프로그램 비정상 종료
    ```
    

### 45.2.3 예외 전파와 콜 스택

메서드 내부에서 오류가 발생하면 메서드는 **예외 객체를 생성하여 런타임 시스템에 전달**한다.

이를 **‘예외를 던진다(throw)’ 라고 한다.**

> #### 💡예외 객체에 담긴 정보
> <ul><li>에러의 종류(타입)</li><li>에러 메시지</li><li>에러가 발생한 시점의 호출 정보(stack trace)</li></ul>


#### 콜 스택(Call Stack)

메서드가 예외를 던지면, 런타임 시스템은 이 예외를 처리할 수 있는 코드가 있는지 찾기 위해 **콜 스택(Call Stack)을 따라 검사한다.**

콜 스택이란, 현재 메서드가 호출되기까지의 호출 순서를 가진 구조이다.

```csharp
Main()
 └─ A()
     └─ B()
         └─ C()
```

C에서 예외가 발생했다고 가정해보자.

런타임 시스템은 다음 순서로 처리할 수 있는 지점을 찾는다.

1.  C 메서드 안에 예외를 처리하는 `catch`가 있는지 검사 (exception handler 블록 검사)
2.  없으면 B 메서드로 이동
3.  B에도 없으면 A 메서드로 이동
4.  A에 적절한 `catch`가 있다면(예외를 잡음) 해당 지점에서 예외를 처리


<img width="421" height="201" alt="image" src="https://github.com/user-attachments/assets/4b783098-9967-4796-b143-a434db781cca" />

출처 : https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html

이렇게 예외가 **콜 스택을 따라 위로 전파되다가,** 콜 스택 상에서 적절한 예외 처리 구문을 찾지 못하면 **프로그램이 비정상 종료된다.**

## 45.3 사전 테스트 메서드 (Try 패턴)

### 예외와 사전 테스트 메서드

예외가 발생하면 다음과 같은 작업이 수행된다.

*   예외 객체 생성
*   스택 트레이스 생성
*   콜 스택 되감기

이 과정은 **일반적인 메서드 호출보다 비용이 크다.**

따라서 예외가 발생가능한 메서드를 작성할 때는 <span class="fontColorRed"><strong>예외 유발 조건을 사전에 검사할 수 있는 메서드(사전 테스트 메서드)</strong></span>를 함께 제공하는 것이 좋다.

### .NET / Unity 예시
| Try 메서드 | 예외 메서드 |
| --- | --- |
| `int.TryParse` | `int.Parse` |
| `Dictionary.TryGetValue` | `dict[key]` |
| `Enum.TryParse` | `Enum.Parse` |
| `Physics.Raycast` | (실패 시 false) |

 

### 예제 코드

```csharp
DoesWorkThatMightFail worker = new DoesWorkThatMightFail();

try
{
   worker.DoWork();  // 예외 발생 조건 체크 x
}
catch (WorkerException e)
{
   ReportErrorToUser(“Test Conditions Failed”);
}
```

```csharp
//예시 : 권장하는 예외 메서드 생성 방식
public class DoesWorkThatMightFail
{
	 // 예외 유발 조건을 검사 후 실행하는 메서드
	 // 예외 발생 조건이 아닐 때만 메서드를 실행하므로 예외 처리 비용을 줄일 수 있다.
      public bool TryDoWork()
      {
          if (!TestConditions())
             return false;

          Work();

          return true;
       }

 
       public void DoWork()
       {
           Work();
       }

       private bool TestConditions()
       {
   	       // 테스트 조건 관련 로직
           return true;
       }
       

       private void Work()
       {
	       // 작업 수행
       }

}
```



